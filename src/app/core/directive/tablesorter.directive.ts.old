import { Directive, ElementRef, Input, OnInit, Renderer2, AfterViewInit } from '@angular/core';

@Directive({
    standalone: true,
    selector: '[tablesorter]'
})
export class TablesorterDirective implements OnInit, AfterViewInit {
    @Input() defaultSortColumn: number = 0;
    @Input() defaultSortDirection: 'asc' | 'desc' = 'asc';
    @Input() data: any[] = [];

    private table: HTMLTableElement;
    private headers: HTMLTableCellElement[] = [];
    private thead: HTMLTableSectionElement | null = null;
    private tbody: HTMLTableSectionElement | null = null;
    private sortDirection: 'asc' | 'desc' = 'asc';
    private currentSortColumn: number = 0;
    private originalRows: HTMLTableRowElement[] = [];
    private tableData: { row: HTMLTableRowElement, cells: string[] }[] = [];
    private initialized: boolean = false;
    private columnWidths: number[] = [];

    constructor(private el: ElementRef, private renderer: Renderer2) {
        this.table = this.el.nativeElement;
    }

    ngOnInit() {
        if (this.table.tagName !== 'TABLE') {
            console.error('Esta directiva solo puede ser usada en elementos <table>');
            return;
        }

        // Agregar clase principal tablesorter a la tabla
        this.renderer.addClass(this.table, 'tablesorter');
        // Añadir layout-fixed para evitar recalculos de ancho
        this.renderer.setStyle(this.table, 'table-layout', 'fixed');
        this.renderer.setStyle(this.table, 'width', '100%');

        this.ensureValidTableStructure();

        this.thead = this.table.querySelector('thead');
        if (!this.thead) {
            console.error('La tabla debe tener un elemento <thead>');
            return;
        }

        const headerRow = this.thead.querySelector('tr');
        if (!headerRow) {
            console.error('El <thead> debe contener al menos una fila <tr>');
            return;
        }

        this.headers = Array.from(headerRow.querySelectorAll('th'));
        if (this.headers.length === 0) {
            console.error('No se encontraron elementos <th> en el encabezado de la tabla');
            return;
        }

        this.tbody = this.table.querySelector('tbody');
        if (!this.tbody) {
            console.error('La tabla debe tener un elemento <tbody>');
            return;
        }

        // Preservar anchos de columnas antes de cualquier manipulación
        this.preserveColumnWidths();

        this.setupHeaderSorting();

        // Agregar estilos CSS a la página
        this.addTableStyles();
    }

    ngAfterViewInit() {
        setTimeout(() => {
            this.captureTableData();
            this.sortTable(this.defaultSortColumn, this.defaultSortDirection);
            this.initialized = true;

            // Asegurar que los anchos de columna se mantienen después de ordenar
            this.enforceColumnWidths();
        }, 0);
    }

    // Método para preservar los anchos de columnas originales
    private preserveColumnWidths() {
        this.columnWidths = this.headers.map(header => {
            // Obtener el ancho computado actual
            const computedWidth = window.getComputedStyle(header).width;
            const width = parseFloat(computedWidth);

            // Fijar el ancho en el elemento para evitar cambios
            this.renderer.setStyle(header, 'width', `${width}px`);

            return width;
        });
    }

    // Método para aplicar los anchos preservados a las columnas
    private enforceColumnWidths() {
        this.headers.forEach((header, index) => {
            if (this.columnWidths[index]) {
                this.renderer.setStyle(header, 'width', `${this.columnWidths[index]}px`);

                // También aplicar a las celdas correspondientes en tbody
                if (this.tbody) {
                    const rows = this.tbody.querySelectorAll('tr');
                    rows.forEach(row => {
                        const cell = row.cells[index];
                        if (cell) {
                            this.renderer.setStyle(cell, 'width', `${this.columnWidths[index]}px`);
                        }
                    });
                }
            }
        });
    }

    private captureTableData() {
        if (!this.tbody) return;
        this.originalRows = Array.from(this.tbody.querySelectorAll('tr'));
        this.storeTableData();
    }

    private setupHeaderSorting() {
        this.headers.forEach((header, index) => {
            this.renderer.addClass(header, 'ordenable');

            if (index === this.defaultSortColumn) {
                this.renderer.addClass(header, this.defaultSortDirection === 'asc' ? 'asc' : 'desc');
                this.currentSortColumn = index;
                this.sortDirection = this.defaultSortDirection;
            }

            this.renderer.listen(header, 'click', (event) => {
                // Prevenir el efecto de selección de texto al hacer clic
                event.preventDefault();
                this.sortColumn(index);
            });
        });
    }

    private storeTableData() {
        this.tableData = [];

        if (this.originalRows.length === 0) {
            console.warn('No se encontraron filas en la tabla.');
            return;
        }

        if (this.data && this.data.length > 0) {
            this.originalRows.forEach((row, rowIndex) => {
                if (rowIndex < this.data.length) {
                    const dataValues = Object.values(this.data[rowIndex])
                        .map(val => val !== null && val !== undefined ? val.toString() : '');

                    this.tableData.push({
                        row: row,
                        cells: dataValues
                    });
                }
            });
        } else {
            this.originalRows.forEach(row => {
                const rowData = Array.from(row.cells).map(cell => cell.textContent || '');
                this.tableData.push({
                    row: row,
                    cells: rowData
                });
            });
        }
    }

    private ensureValidTableStructure() {
        if (!this.table.querySelector('thead') && !this.table.querySelector('tbody')) {
            const rows = Array.from(this.table.querySelectorAll('tr'));

            if (rows.length > 0) {
                const thead = this.renderer.createElement('thead');
                this.renderer.appendChild(thead, rows[0].cloneNode(true));

                const headerRow = thead.querySelector('tr');
                if (headerRow) {
                    Array.from(headerRow.querySelectorAll('td')).forEach((td: any) => {
                        const th = this.renderer.createElement('th');
                        this.renderer.appendChild(th, this.renderer.createText(td.textContent || ''));
                        headerRow.replaceChild(th, td);
                    });
                }

                const tbody = this.renderer.createElement('tbody');
                for (let i = 1; i < rows.length; i++) {
                    this.renderer.appendChild(tbody, rows[i].cloneNode(true));
                }

                while (this.table.firstChild) {
                    this.table.removeChild(this.table.firstChild);
                }

                this.renderer.appendChild(this.table, thead);
                this.renderer.appendChild(this.table, tbody);
            }
        }
    }

    private sortColumn(index: number) {
        if (index === this.currentSortColumn) {
            this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            this.sortDirection = 'asc';
        }

        this.headers.forEach(header => {
            this.renderer.removeClass(header, 'asc');
            this.renderer.removeClass(header, 'desc');
        });

        this.renderer.addClass(this.headers[index], this.sortDirection);
        this.currentSortColumn = index;

        // Preservar anchos antes de ordenar
        this.preserveColumnWidths();

        this.sortTable(index, this.sortDirection);

        // Restaurar anchos después de ordenar
        this.enforceColumnWidths();
    }

    private sortTable(columnIndex: number, direction: 'asc' | 'desc') {
        if (!this.tbody) return;

        const rows = Array.from(this.tbody.querySelectorAll('tr'));

        if (rows.length === 0 || (rows.length === 1 && rows[0].cells.length === 1 &&
            rows[0].cells[0].getAttribute('colspan'))) {
            return;
        }

        const sortedRows = rows.sort((rowA, rowB) => {
            if (columnIndex >= rowA.cells.length || columnIndex >= rowB.cells.length) {
                return 0;
            }

            const cellA = rowA.cells[columnIndex]?.textContent || '';
            const cellB = rowB.cells[columnIndex]?.textContent || '';

            const valueA = this.parseValue(cellA);
            const valueB = this.parseValue(cellB);

            if (direction === 'asc') {
                return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
            } else {
                return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
            }
        });

        this.clearTbody();

        sortedRows.forEach(row => {
            this.tbody?.appendChild(row);
        });
    }

    private clearTbody() {
        if (!this.tbody) return;

        const rows = Array.from(this.tbody.querySelectorAll('tr'));
        rows.forEach(row => {
            this.renderer.removeChild(this.tbody!, row);
        });
    }

    private parseValue(value: string) {
        const cleanValue = value.replace(/[^\d.-]/g, '');

        const date = new Date(value);
        if (!isNaN(date.getTime())) {
            return date.getTime();
        }

        const num = parseFloat(cleanValue);
        if (!isNaN(num)) {
            return num;
        }

        return value.toLowerCase();
    }

    // Método para agregar los estilos CSS a la página
    private addTableStyles() {
        const styleEl = this.renderer.createElement('style');
        const css = `
        /* Estilos base para la tabla */
        .tablesorter {
          width: 100%;
          border-collapse: collapse;
          font-family: Arial, sans-serif;
          font-size: 14px;
          background-color: #fff;
          /* Importante: Fijar el layout de la tabla */
          table-layout: fixed;
          /* Evitar transformaciones */
          backface-visibility: visible;
          transform: none;
        }
    
        /* Estilos para las cabeceras */
        .tablesorter thead tr th {
          padding: 0 10px;
          height: 50px;
          vertical-align: middle;
          background-color: #f5f5f5;
          color: #666;
          font-weight: 500;
          border: none;
          text-align: left;
          cursor: pointer;
          user-select: none;
          /* Establecer overflow para contenido largo */
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
          /* Usar position relative en lugar de transform */
          position: relative;
          z-index: 1;
        }
    
        /* Estilos para las flechas de ordenamiento */
        .tablesorter .ordenable.asc::after {
          content: ' ▲';
          font-size: 12px;
          color: #888;
        }
        
        .tablesorter .ordenable.desc::after {
          content: ' ▼';
          font-size: 12px;
          color: #888;
        }
        
        /* Hover en las cabeceras */
        .tablesorter .ordenable:hover {
          background-color: rgba(0, 0, 0, 0.02);
        }
    
        /* Estilos para las celdas */
        .tablesorter tbody tr td {
          padding: 8px 10px;
          vertical-align: middle;
          border-bottom: 1px solid rgba(0, 0, 0, 0.09);
          color: #666;
          /* Configurar overflow para contenido largo */
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
          /* Posición relativa en lugar de transform */
          position: relative;
        }
    
        /* Estilos para filas alternadas */
        .tablesorter tbody tr:nth-child(odd) {
          background-color: #f9f9f9;
        }
    
        .tablesorter tbody tr:nth-child(even) {
          background-color: #ffffff;
        }
        
        /* Efecto hover en las filas - con selector !important pero sin transformaciones */
        .tablesorter tbody tr {
          transition: background-color 0.15s ease-in-out;
          /* Eliminamos transformaciones que pueden causar temblor */
          transform: none;
          backface-visibility: visible;
        }
        
        .tablesorter tbody tr:hover {
          background-color: rgba(0, 120, 215, 0.05) !important;
        }`;

        this.renderer.appendChild(styleEl, this.renderer.createText(css));
        this.renderer.appendChild(document.head, styleEl);
    }
}