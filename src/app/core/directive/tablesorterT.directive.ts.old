import { Directive, ElementRef, OnInit, Input, Renderer2, AfterViewInit, OnChanges, SimpleChanges } from '@angular/core';

@Directive({
    standalone: true,
    selector: '[tablesorterT]'
})
export class TablesorterTDirective implements OnInit, AfterViewInit, OnChanges {
    @Input() defaultSortColumn: number = 0;
    @Input() defaultSortDirection: 'asc' | 'desc' = 'asc';
    @Input() filter: boolean = true;
    @Input() sticky: boolean = false;
    @Input() data: any[] = [];

    private table: HTMLTableElement;
    private headers: HTMLTableCellElement[] = [];
    private thead: HTMLTableSectionElement | null = null;
    private tbody: HTMLTableSectionElement | null = null;
    private sortDirection: 'asc' | 'desc' = 'asc';
    private currentSortColumn: number = 0;
    private filterInputs: HTMLInputElement[] = [];
    private originalRows: HTMLTableRowElement[] = [];
    private tableData: { row: HTMLTableRowElement, cells: string[] }[] = [];
    private initialized: boolean = false;
    private tableWrapper: HTMLDivElement | null = null;

    private regex = {
        regex: /^\/((?:\\\/|[^\/])+)\/([migyu]{0,5})?$/,
        child: /tablesorter-childRow/,
        filtered: /filtered/,
        type: /undefined|number/,
        exact: /(^[\"\'=]+)|([\"\'=]+$)/g,
        operators: /[<>=]=?/g,
        query: '(q|query)',
        wild01: /\?/g,
        wild0More: /\*/g,
        quote: /\"/g,
        isNeg1: /(>=?\s*-\d)/,
        isNeg2: /(<=?\s*\d)/,
    };

    constructor(private el: ElementRef, private renderer: Renderer2) {
        this.table = this.el.nativeElement;
    }

    ngOnInit() {
        if (this.table.tagName !== 'TABLE') {
            console.error('Esta directiva solo puede ser usada en elementos <table>');
            return;
        }

        // Agregar clase principal tablesorter a la tabla
        this.renderer.addClass(this.table, 'tablesorter');

        this.ensureValidTableStructure();

        this.thead = this.table.querySelector('thead');
        if (!this.thead) {
            console.error('La tabla debe tener un elemento <thead>');
            return;
        }

        const headerRow = this.thead.querySelector('tr');
        if (!headerRow) {
            console.error('El <thead> debe contener al menos una fila <tr>');
            return;
        }

        this.headers = Array.from(headerRow.querySelectorAll('th'));
        if (this.headers.length === 0) {
            console.error('No se encontraron elementos <th> en el encabezado de la tabla');
            return;
        }

        this.tbody = this.table.querySelector('tbody');
        if (!this.tbody) {
            console.error('La tabla debe tener un elemento <tbody>');
            return;
        }

        this.setupHeaderSorting();

        if (this.filter) {
            this.addFilterRow();
        }

        if (this.sticky) {
            this.applyStickyHeaders();
        }

        // Agregar estilos CSS a la página
        this.addTableStyles();
    }

    ngAfterViewInit() {
        setTimeout(() => {
            this.captureTableData();
            this.sortTable(this.defaultSortColumn, this.defaultSortDirection);
            this.initialized = true;
        }, 0);
    }

    ngOnChanges(changes: SimpleChanges) {
        if (changes['data'] && this.initialized) {
            setTimeout(() => {
                this.refreshTable();
            }, 0);
        }

        if (changes['sticky'] && this.initialized) {
            setTimeout(() => {
                if (this.sticky) {
                    this.applyStickyHeaders();
                } else {
                    this.removeStickyHeaders();
                }
            }, 0);
        }
    }

    private applyStickyHeaders() {
        // Si ya existe un wrapper, eliminarlo primero para no duplicar
        if (this.tableWrapper) {
            this.removeStickyHeaders();
        }

        // Solo creamos un contenedor con scroll cuando sticky=true
        this.tableWrapper = this.renderer.createElement('div');
        this.renderer.addClass(this.tableWrapper, 'tablesorter-wrapper');

        // Añadir clase para indicar que tiene scroll
        this.renderer.addClass(this.tableWrapper, 'has-scroll');

        const parent = this.table.parentNode;
        if (!parent) return;

        this.renderer.insertBefore(parent, this.tableWrapper, this.table);
        this.renderer.removeChild(parent, this.table);
        this.renderer.appendChild(this.tableWrapper, this.table);

        if (this.thead) {
            this.renderer.addClass(this.thead, 'sticky-header');
        }

        const filterRow = this.thead?.querySelector('.filter-row');
        if (filterRow) {
            this.renderer.addClass(filterRow, 'sticky-filter');
        }

        // Evitar que el scroll de la página afecte al contenido de la tabla
        // Esto previene el temblor al hacer scroll en la página
        this.preventScrollJitter();
    }

    private preventScrollJitter() {
        if (!this.tableWrapper) return;

        // Utilizar will-change: transform para forzar composición de capa
        this.renderer.setStyle(this.tableWrapper, 'will-change', 'transform');

        // Forzar una capa de composición separada para el contenedor de la tabla
        this.renderer.setStyle(this.tableWrapper, 'transform', 'translateZ(0)');

        // Importante: habilitar overlay scrolling cuando esté disponible
        this.renderer.setStyle(this.tableWrapper, 'overflow-y', 'auto');
        this.renderer.setStyle(this.tableWrapper, '-webkit-overflow-scrolling', 'touch');

        // Para cabeceras sticky, forzar también composición de capa
        if (this.thead) {
            this.renderer.setStyle(this.thead, 'will-change', 'transform');
            this.renderer.setStyle(this.thead, 'transform', 'translateZ(0)');
        }
    }

    private removeStickyHeaders() {
        if (!this.tableWrapper) return;

        const parent = this.tableWrapper.parentNode;
        if (!parent) return;

        if (this.thead) {
            this.renderer.removeClass(this.thead, 'sticky-header');
            // Quitar estilos de prevención de temblor
            this.renderer.removeStyle(this.thead, 'will-change');
            this.renderer.removeStyle(this.thead, 'transform');
        }

        const filterRow = this.thead?.querySelector('.filter-row');
        if (filterRow) {
            this.renderer.removeClass(filterRow, 'sticky-filter');
        }

        this.renderer.removeChild(this.tableWrapper, this.table);
        this.renderer.insertBefore(parent, this.table, this.tableWrapper);
        this.renderer.removeChild(parent, this.tableWrapper);
        this.tableWrapper = null;
    }

    private captureTableData() {
        if (!this.tbody) return;
        this.originalRows = Array.from(this.tbody.querySelectorAll('tr'));
        this.storeTableData();
    }

    private refreshTable() {
        if (!this.tbody) return;

        this.captureTableData();

        if (this.filterInputs.length > 0) {
            this.filterInputs.forEach(input => {
                if (input) input.value = '';
            });
        }

        this.resetFilters();
    }

    private setupHeaderSorting() {
        this.headers.forEach((header, index) => {
            this.renderer.addClass(header, 'ordenable');

            if (index === this.defaultSortColumn) {
                this.renderer.addClass(header, this.defaultSortDirection === 'asc' ? 'asc' : 'desc');
                this.currentSortColumn = index;
                this.sortDirection = this.defaultSortDirection;
            }

            this.renderer.listen(header, 'click', () => {
                this.sortColumn(index);
            });
        });
    }

    private storeTableData() {
        this.tableData = [];

        if (this.originalRows.length === 0) {
            console.warn('No se encontraron filas en la tabla.');
            return;
        }

        if (this.data && this.data.length > 0) {
            this.originalRows.forEach((row, rowIndex) => {
                if (rowIndex < this.data.length) {
                    const dataValues = Object.values(this.data[rowIndex])
                        .map(val => val !== null && val !== undefined ? val.toString() : '');

                    this.tableData.push({
                        row: row,
                        cells: dataValues
                    });
                }
            });
        } else {
            this.originalRows.forEach(row => {
                const rowData = Array.from(row.cells).map(cell => cell.textContent || '');
                this.tableData.push({
                    row: row,
                    cells: rowData
                });
            });
        }
    }

    private ensureValidTableStructure() {
        if (!this.table.querySelector('thead') && !this.table.querySelector('tbody')) {
            const rows = Array.from(this.table.querySelectorAll('tr'));

            if (rows.length > 0) {
                const thead = this.renderer.createElement('thead');
                this.renderer.appendChild(thead, rows[0].cloneNode(true));

                const headerRow = thead.querySelector('tr');
                if (headerRow) {
                    Array.from(headerRow.querySelectorAll('td')).forEach((td: any) => {
                        const th = this.renderer.createElement('th');
                        this.renderer.appendChild(th, this.renderer.createText(td.textContent || ''));
                        headerRow.replaceChild(th, td);
                    });
                }

                const tbody = this.renderer.createElement('tbody');
                for (let i = 1; i < rows.length; i++) {
                    this.renderer.appendChild(tbody, rows[i].cloneNode(true));
                }

                while (this.table.firstChild) {
                    this.table.removeChild(this.table.firstChild);
                }

                this.renderer.appendChild(this.table, thead);
                this.renderer.appendChild(this.table, tbody);
            }
        }
    }

    private addFilterRow() {
        const existingFilterRow = this.thead!.querySelector('.filter-row');
        if (existingFilterRow) {
            this.renderer.removeChild(this.thead, existingFilterRow);
        }

        const filterRow = this.renderer.createElement('tr');
        this.renderer.addClass(filterRow, 'filter-row');

        this.headers.forEach((header, index) => {
            const filterCell = this.renderer.createElement('th');
            this.renderer.addClass(filterCell, 'filter-cell');

            const input = this.renderer.createElement('input');
            this.renderer.setAttribute(input, 'type', 'search');
            this.renderer.setAttribute(input, 'placeholder', ``);
            this.renderer.addClass(input, 'filter-input');

            this.renderer.listen(input, 'input', () => {
                const filterValue = input.value;
                this.applyColumnFilter(index, filterValue);
            });

            this.filterInputs[index] = input;
            this.renderer.appendChild(filterCell, input);
            this.renderer.appendChild(filterRow, filterCell);
        });

        this.renderer.appendChild(this.thead!, filterRow);

        // Si ya existe un encabezado sticky, aplicar también al filtro
        if (this.thead?.classList.contains('sticky-header')) {
            this.renderer.addClass(filterRow, 'sticky-filter');

            // Prevenir temblor en la fila de filtros
            this.renderer.setStyle(filterRow, 'will-change', 'transform');
            this.renderer.setStyle(filterRow, 'transform', 'translateZ(0)');
        }
    }

    private applyColumnFilter(columnIndex: number, filterValue: string) {
        const allFilters = this.filterInputs.map(input => input ? input.value : '');
        this.applyAllFilters(allFilters);
    }

    private applyAllFilters(filterValues: string[] = []) {
        if (!this.tbody || this.tableData.length === 0) return;

        if (filterValues.length === 0) {
            filterValues = this.filterInputs.map(input =>
                input ? input.value : '');
        }

        const hasActiveFilters = filterValues.some(value => value.length > 0);

        if (!hasActiveFilters) {
            this.resetFilters();
            return;
        }

        this.clearTbody();

        const filteredRows = this.tableData.filter(item => {
            for (let i = 0; i < Math.min(item.cells.length, filterValues.length); i++) {
                const cellText = item.cells[i];
                const filterValue = filterValues[i];

                if (filterValue && !this.applyFilter(cellText, filterValue)) {
                    return false;
                }
            }
            return true;
        });

        filteredRows.forEach(item => {
            this.tbody?.appendChild(item.row.cloneNode(true));
        });

        if (filteredRows.length === 0) {
            this.showNoResultsMessage();
        }

        this.sortTable(this.currentSortColumn, this.sortDirection);
    }

    private showNoResultsMessage() {
        if (!this.tbody) return;

        const noResultsRow = this.renderer.createElement('tr');
        const cell = this.renderer.createElement('td');

        this.renderer.setAttribute(cell, 'colspan', this.headers.length.toString());
        this.renderer.addClass(cell, 'no-results');

        const message = this.renderer.createText('No se encontraron resultados para el filtro actual.');
        this.renderer.appendChild(cell, message);
        this.renderer.appendChild(noResultsRow, cell);
        this.renderer.appendChild(this.tbody, noResultsRow);
    }

    private applyFilter(itemValue: string, filterValue: string): boolean {
        if (!filterValue) return true;

        const normalizedItemValue = itemValue.toLowerCase();
        let exactMatch = false;

        if (this.regex.exact.test(filterValue)) {
            exactMatch = true;
            filterValue = filterValue.replace(this.regex.exact, '');
        }

        if (exactMatch) {
            return normalizedItemValue === filterValue.toLowerCase();
        }

        if (this.regex.operators.test(filterValue)) {
            let operatorMatch = filterValue.match(this.regex.operators);
            if (operatorMatch) {
                let operator = operatorMatch[0];
                let value = filterValue.split(operator)[1].trim();

                let itemNumber = parseFloat(itemValue);
                let filterNumber = parseFloat(value);
                let itemDate = new Date(itemValue);
                let filterDate = new Date(value);

                if (!isNaN(itemNumber) && !isNaN(filterNumber)) {
                    switch (operator) {
                        case '>': return itemNumber > filterNumber;
                        case '<': return itemNumber < filterNumber;
                        case '>=': return itemNumber >= filterNumber;
                        case '<=': return itemNumber <= filterNumber;
                        case '==': return itemNumber == filterNumber;
                    }
                }

                if (!isNaN(itemDate.getTime()) && !isNaN(filterDate.getTime())) {
                    switch (operator) {
                        case '>': return itemDate > filterDate;
                        case '<': return itemDate < filterDate;
                        case '>=': return itemDate >= filterDate;
                        case '<=': return itemDate <= filterDate;
                        case '==': return itemDate.getTime() === filterDate.getTime();
                    }
                }
            }
        }

        let wildcard = filterValue
            .replace(this.regex.wild01, '.')
            .replace(this.regex.wild0More, '.*');

        try {
            let wildcardRegex = new RegExp(wildcard, 'i');
            return wildcardRegex.test(itemValue);
        } catch (e) {
            return normalizedItemValue.includes(filterValue.toLowerCase());
        }
    }

    private clearTbody() {
        if (!this.tbody) return;

        const rows = Array.from(this.tbody.querySelectorAll('tr'));
        rows.forEach(row => {
            this.tbody?.removeChild(row);
        });
    }

    private resetFilters() {
        this.filterInputs.forEach(input => {
            if (input) input.value = '';
        });

        this.clearTbody();

        this.originalRows.forEach(row => {
            this.tbody?.appendChild(row.cloneNode(true));
        });

        this.sortTable(this.currentSortColumn, this.sortDirection);
    }

    private sortColumn(index: number) {
        if (index === this.currentSortColumn) {
            this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            this.sortDirection = 'asc';
        }

        this.headers.forEach(header => {
            this.renderer.removeClass(header, 'asc');
            this.renderer.removeClass(header, 'desc');
        });

        this.renderer.addClass(this.headers[index], this.sortDirection);
        this.currentSortColumn = index;
        this.sortTable(index, this.sortDirection);
    }

    private sortTable(columnIndex: number, direction: 'asc' | 'desc') {
        if (!this.tbody) return;

        const rows = Array.from(this.tbody.querySelectorAll('tr'));

        if (rows.length === 0 || (rows.length === 1 && rows[0].cells.length === 1 &&
            rows[0].cells[0].getAttribute('colspan'))) {
            return;
        }

        const sortedRows = rows.sort((rowA, rowB) => {
            if (columnIndex >= rowA.cells.length || columnIndex >= rowB.cells.length) {
                return 0;
            }

            const cellA = rowA.cells[columnIndex]?.textContent || '';
            const cellB = rowB.cells[columnIndex]?.textContent || '';

            const valueA = this.parseValue(cellA);
            const valueB = this.parseValue(cellB);

            if (direction === 'asc') {
                return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
            } else {
                return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
            }
        });

        this.clearTbody();

        sortedRows.forEach(row => {
            this.tbody?.appendChild(row);
        });
    }

    private parseValue(value: string) {
        const cleanValue = value.replace(/[^\d.-]/g, '');

        const date = new Date(value);
        if (!isNaN(date.getTime())) {
            return date.getTime();
        }

        const num = parseFloat(cleanValue);
        if (!isNaN(num)) {
            return num;
        }

        return value.toLowerCase();
    }

    // Método para agregar los estilos CSS a la página
    private addTableStyles() {
        const styleEl = this.renderer.createElement('style');
        const css = `
      /* Estilos base para la tabla */
      .tablesorter {
        width: 100%;
        border-collapse: collapse;
        font-family: Arial, sans-serif;
        font-size: 14px;
        background-color: #fff;
        /* Prevenir temblor en toda la tabla */
        backface-visibility: hidden;
        transform: translateZ(0);
      }

      /* Estilos para las cabeceras */
      .tablesorter thead tr th {
        padding: 0 10px;
        height: 50px;
        vertical-align: middle;
        background-color: #f5f5f5;
        color: #666;
        font-weight: 500;
        border: none;
        text-align: left;
        cursor: pointer;
        user-select: none;
        /* Prevenir temblor */
        position: relative;
        z-index: 1;
      }

      /* Estilos para las flechas de ordenamiento */
      .tablesorter .ordenable.asc::after {
        content: ' ▲';
        font-size: 12px;
        color: #888;
      }
      
      .tablesorter .ordenable.desc::after {
        content: ' ▼';
        font-size: 12px;
        color: #888;
      }
      
      /* Hover en las cabeceras */
      .tablesorter .ordenable:hover {
        background-color: rgba(0, 0, 0, 0.02);
      }

      /* Estilos para las celdas */
      .tablesorter tbody tr td {
        padding: 8px 10px;
        vertical-align: middle;
        border-bottom: 1px solid rgba(0, 0, 0, 0.09);
        color: #666;
        /* Prevenir temblor */
        position: relative;
      }

      /* Estilos para filas alternadas */
      .tablesorter tbody tr:nth-child(odd) {
        background-color: #f9f9f9;
      }

      .tablesorter tbody tr:nth-child(even) {
        background-color: #ffffff;
      }
      
      /* Efecto hover en las filas - con selector !important */
      .tablesorter tbody tr {
        transition: background-color 0.15s ease-in-out;
        /* Prevenir temblor */
        transform: translateZ(0);
        backface-visibility: hidden;
      }
      
      .tablesorter tbody tr:hover {
        background-color: rgba(0, 120, 215, 0.05) !important;
      }

      /* Estilos para la fila de filtros */
      .tablesorter .filter-row th {
        padding: 0 10px !important;
        height: 40px !important;
        background-color: #f0f0f0;
        font-weight: normal;
        position: relative;
        z-index: 1;
      }
      
      /* Estilos para los inputs de filtro */
      .tablesorter .filter-input {
        width: 100%;
        box-sizing: border-box;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 3px;
      }
      
      .tablesorter .filter-input:focus {
        outline: none;
        border-color: #4d90fe;
        box-shadow: 0 0 3px rgba(77, 144, 254, 0.5);
      }

      /* Estilos para el mensaje sin resultados */
      .tablesorter .no-results {
        text-align: center;
        padding: 20px;
        color: #666;
      }
      
      /* Estilos para el contenedor con scroll */
      .tablesorter-wrapper {
        position: relative;
        margin-bottom: 20px;
        /* IMPORTANTE: Propiedades para prevenir temblor */
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        will-change: transform;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        perspective: 1000px;
        -webkit-perspective: 1000px;
      }
      
      /* El scroll interno solo se aplica cuando tiene la clase has-scroll */
      .tablesorter-wrapper.has-scroll {
        max-height: 500px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      .tablesorter-wrapper:not(.has-scroll) {
        overflow: visible;
        max-height: none;
      }
      
      /* Cabeceras fijas - solo activas cuando hay scroll */
      .tablesorter .sticky-header {
        position: sticky;
        top: 0;
        z-index: 2;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        /* Prevenir temblor */
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        will-change: transform;
      }
      
      .tablesorter .sticky-filter {
        position: sticky;
        top: 50px;
        z-index: 1;
        /* Prevenir temblor */
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        will-change: transform;
      }

      /* ESTILOS PARA MODO OSCURO */
      .dark .tablesorter {
        background-color: #1a1e25;
      }

      /* Cabeceras en modo oscuro */
      .dark .tablesorter thead tr th {
        border-bottom: 1px solid #15181d;
        border-top: 1px solid #15181d;
        background-color: #15181d;
        color: #abaaaa;
      }

      /* Celdas en modo oscuro */
      .dark .tablesorter tbody tr td {
        color: #abaaaa;
        border-bottom-color: rgba(21, 24, 29, 0.5);
      }

      /* Filas alternadas en modo oscuro */
      .dark .tablesorter tbody tr:nth-child(odd) {
        background-color: #1e2129;
      }

      .dark .tablesorter tbody tr:nth-child(even) {
        background-color: #1a1e25;
      }
      
      /* Hover en filas en modo oscuro - con selector !important */
      .dark .tablesorter tbody tr:hover {
        background-color: #24272f !important;
      }

      /* Fila de filtros en modo oscuro */
      .dark .tablesorter .filter-row th {
        background-color: #1a1d24;
        color: #abaaaa;
        border-bottom: 1px solid #15181d;
      }
      
      /* Inputs de filtro en modo oscuro */
      .dark .tablesorter .filter-input {
        background-color: #272b33;
        color: #abaaaa;
        border: 1px solid #15181d;
      }

      /* Mensaje sin resultados en modo oscuro */
      .dark .tablesorter .no-results {
        color: #abaaaa;
      }
      
      /* Sombras en modo oscuro */
      .dark .tablesorter .sticky-header {
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      }
    `;

        this.renderer.appendChild(styleEl, this.renderer.createText(css));
        this.renderer.appendChild(document.head, styleEl);
    }
}